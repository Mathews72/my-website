<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tetris</title>
  <style>
    body { display: flex; flex-direction: column; align-items: center; background: #222; color: #fff; font-family: sans-serif; }
    #gameCanvas { background: #000; margin-top: 20px; }
    #info { margin-top: 10px; }
    #nextCanvas { background: #111; margin-left: 20px; }
    .container { display: flex; }
  </style>
</head>
<body>
  <h1>Tetris</h1>
  <div class="container">
    <canvas id="gameCanvas" width="240" height="400"></canvas>
    <div id="info">
      <canvas id="nextCanvas" width="120" height="120"></canvas>
      <p>Score: <span id="score">0</span></p>
      <p>Level: <span id="level">1</span></p>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const COLS = 10, ROWS = 20, BLOCK = 20;
    let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    const colors = [null, '#0ff', '#f0f', '#ff0', '#0f0', '#00f', '#f00', '#fa0'];
    const pieces = [
      [0x0F00, '#0ff'], [0x4444, '#0f0'], [0x0E40, '#f0f'], [0x4C40, '#ff0'],
      [0x4E00, '#00f'], [0x8E00, '#f00'], [0x2E00, '#fa0']
    ];
    function rotate(piece) {
      return (piece % 2 === 0)
        ? ((piece >>> 8) | ((piece & 0xFF) << 8))
        : (piece & 0x0F00) << 4;
    }
    class Piece {
      constructor(type) {
        this.type = type;
        this.color = pieces[type][1];
        this.x = 3; this.y = 0;
        this.shape = pieces[type][0];
      }
      rotate() { this.shape = rotate(this.shape); }
    }
    let current = new Piece(~~(Math.random() * pieces.length));
    let next = new Piece(~~(Math.random() * pieces.length));
    let score = 0, level = 1, dropInterval = 1000, dropCounter = 0;
    let lastTime = 0;
    function collide() {
      for (let y = 0; y < 4; ++y) {
        for (let x = 0; x < 4; ++x) {
          if ((current.shape & (0x8000 >> (y*4 + x))) !== 0) {
            if (board[current.y + y] && board[current.y + y][current.x + x]) {
              return true;
            }
          }
        }
      }
      return false;
    }
    function merge() {
      for (let y = 0; y < 4; ++y) {
        for (let x = 0; x < 4; ++x) {
          if ((current.shape & (0x8000 >> (y*4 + x))) !== 0) {
            board[current.y + y][current.x + x] = colors.indexOf(current.color);
          }
        }
      }
    }
    function sweep() {
      let rowCount = 1;
      outer: for (let y = ROWS - 1; y >= 0; --y) {
        for (let x = 0; x < COLS; ++x) {
          if (!board[y][x]) {
            continue outer;
          }
        }
        const row = board.splice(y, 1)[0].fill(0);
        board.unshift(row);
        score += rowCount * 10;
        rowCount *= 2;
      }
      scoreEl.textContent = score;
      level = Math.floor(score / 100) + 1;
      levelEl.textContent = level;
      dropInterval = 1000 - (level - 1) * 100;
    }
    function drawSquare(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
      ctx.strokeStyle = '#222';
      ctx.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
    }
    function drawBoard() {
      board.forEach((row, y) => row.forEach((val, x) => {
        if (val) drawSquare(x, y, colors[val]);
      }));
    }
    function drawPiece(piece, ctxRef=ctx, offsetX=0, offsetY=0) {
      const shape = piece.shape;
      for (let y = 0; y < 4; ++y) {
        for (let x = 0; x < 4; ++x) {
          if (shape & (0x8000 >> (y * 4 + x))) {
            ctxRef.fillStyle = piece.color;
            ctxRef.fillRect((piece.x + x - offsetX) * BLOCK, (piece.y + y - offsetY) * BLOCK, BLOCK, BLOCK);
            ctxRef.strokeStyle = '#222';
            ctxRef.strokeRect((piece.x + x - offsetX) * BLOCK, (piece.y + y - offsetY) * BLOCK, BLOCK, BLOCK);
          }
        }
      }
    }
    function drawNext() {
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      drawPiece(next, nextCtx, 1, 1);
    }
    function update(time = 0) {
      const delta = time - lastTime;
      lastTime = time;
      dropCounter += delta;
      if (dropCounter > dropInterval) {
        current.y++;
        if (collide()) {
          current.y--;
          merge();
          sweep();
          current = next;
          next = new Piece(~~(Math.random() * pieces.length));
          current.x = 3; current.y = 0;
          if (collide()) board = board.map(row => row.fill(0)), score = 0;
          drawNext();
        }
        dropCounter = 0;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBoard();
      drawPiece(current);
      requestAnimationFrame(update);
    }
    document.addEventListener('keydown', ({ keyCode }) => {
      if (keyCode === 37) { current.x--; if (collide()) current.x++; }
      else if (keyCode === 39) { current.x++; if (collide()) current.x--; }
      else if (keyCode === 40) { current.y++; if (collide()) current.y--; dropCounter = 0; }
      else if (keyCode === 81) { current.rotate(); if (collide()) current.rotate(); }
      else if (keyCode === 87) { current.rotate(); if (collide()) current.rotate(); }
    });
    drawNext();
    update();
  </script>
</body>
</html>
